<!DOCTYPE html>
<html lang="en">
<head>
    <title>$pagetitle</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; position: relative; }
        #overlay {
            position: absolute; top: 10px; right: 10px; width: 300px;
            background: rgba(255,255,255,0.95); padding: 15px;
            border-radius: 8px; display: none; max-height: 80vh; overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 10;
        }
        h3 { margin-top: 0; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        .prop-group { margin-bottom: 10px; }
        .prop-group strong { display: block; background: #eee; padding: 2px 5px; font-size: 0.9em; }
        .prop-row { display: flex; font-size: 0.85em; padding: 2px 5px; border-bottom: 1px solid #f5f5f5; }
        .prop-key { width: 40%; color: #666; }
        .prop-val { width: 60%; font-weight: bold; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.7); color: white; padding: 20px; border-radius: 5px;
            font-size: 1.2em; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="loading">Loading BIM Model...</div>
    <div id="overlay">
        <h3 id="prop-title">Element</h3>
        <div id="prop-content"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/+esm",
            "@thatopen/fragments": "https://cdn.jsdelivr.net/npm/@thatopen/fragments@3.3.2/+esm",
            "@thatopen/components": "https://cdn.jsdelivr.net/npm/@thatopen/components@3.3.1/+esm",
            "@thatopen/components-front": "https://cdn.jsdelivr.net/npm/@thatopen/components-front@3.3.1/+esm"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as OBC from '@thatopen/components';
        import * as OBCF from '@thatopen/components-front';

        const data = $data;
        const container = document.getElementById('container');

        // Initialize the core components.
        const components = new OBC.Components();
        const worlds = components.get(OBC.Worlds);
        const world = worlds.create();

        world.scene = new OBC.SimpleScene(components);
        world.renderer = new OBC.SimpleRenderer(components, container);
        world.camera = new OBC.SimpleCamera(components);

        components.init();

        // Initialize FragmentsManager to satisfy Highlighter dependency
        const fragments = components.get(OBC.FragmentsManager);
        fragments.init();

        world.scene.setup();
        world.scene.three.background = new THREE.Color(0xf0f0f0);

        // Define the base90 decoding logic.
        const base = data.base;
        const baseFloat = data.baseFloat;

        function baseDecode(input) {
            const baseCt = base.length;
            const output = [];
            const len = parseInt(input[0]);
            for (let i = 1; i < input.length; i += len) {
                const str = input.substring(i, i + len).trim();
                let val = 0;
                for (let s = 0; s < str.length; s++) {
                    const ind = base.indexOf(str[s]);
                    val += ind * Math.pow(baseCt, s);
                }
                output.push(val);
            }
            return output;
        }

        function floatDecode(input) {
            const baseCt = base.length;
            const baseFloatCt = baseFloat.length;
            let numString = '';
            for (let i = 0; i < input.length; i += 4) {
                const b90chunk = input.substring(i, i + 4).trim();
                let quotient = 0;
                for (let s = 0; s < b90chunk.length; s++) {
                    const ind = base.indexOf(b90chunk[s]);
                    quotient += ind * Math.pow(baseCt, s);
                }
                let buffer = '';
                for (let s = 0; s < 7; s++) {
                    buffer = baseFloat[quotient % baseFloatCt] + buffer;
                    quotient = parseInt(quotient / baseFloatCt);
                }
                numString += buffer;
            }
            let trailingCommas = 0;
            for (let s = 1; s < 7; s++) {
                if (numString[numString.length - s] == baseFloat[0]) {
                    trailingCommas++;
                }
            }
            numString = numString.substring(0, numString.length - trailingCommas);
            return numString;
        }

        const propertiesMap = new Map();

        // Process and decode the geometry.
        if (data.compressed) {
            for (const obj of data.objects) {
                obj.floats = JSON.parse('[' + floatDecode(obj.floats) + ']');
                obj.verts = baseDecode(obj.verts).map(x => obj.floats[x]);
                obj.facets = baseDecode(obj.facets);
            }
        } else {
            for (const obj of data.objects) {
                obj.verts = obj.verts.map(x => parseFloat(x));
            }
        }

        // Build 3D objects using standard Three.js meshes.
        // Registering standard meshes with world.meshes allows ThatOpen components
        // to interact with them via the shared raycaster.
        for (const obj of data.objects) {
            if (obj.verts.length === 0) continue;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(obj.facets.length * 3);
            for (let i = 0; i < obj.facets.length; i++) {
                const idx = obj.facets[i] * 3;
                positions[i*3] = obj.verts[idx];
                positions[i*3+1] = obj.verts[idx+1];
                positions[i*3+2] = obj.verts[idx+2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshLambertMaterial({
                color: new THREE.Color(obj.color),
                transparent: obj.opacity < 1,
                opacity: obj.opacity
            });

            const mesh = new THREE.Mesh(geometry, material);

            // Add to the rendering scene and the ThatOpen interaction set.
            world.scene.three.add(mesh);
            world.meshes.add(mesh);

            propertiesMap.set(mesh.uuid, {
                name: obj.name,
                type: obj.ifc_type,
                psets: obj.psets
            });
        }

        // Setup the highlighter for interaction.
        const highlighter = components.get(OBCF.Highlighter);
        highlighter.setup({ world });
        highlighter.enabled = true;

        const overlay = document.getElementById('overlay');
        const propTitle = document.getElementById('prop-title');
        const propContent = document.getElementById('prop-content');

        container.addEventListener('click', async () => {
            // Highlighting returns the raycast intersection for standard meshes.
            const selection = await highlighter.highlight('select', true);
            if (selection && selection.object) {
                const props = propertiesMap.get(selection.object.uuid);
                if (props) {
                    overlay.style.display = 'block';
                    propTitle.innerText = props.name;
                    let html = `<div class="prop-group"><strong>Type</strong>` +
                               `<div class="prop-row">${props.type}</div></div>`;

                    for (const [psetName, pset] of Object.entries(props.psets)) {
                        html += `<div class="prop-group"><strong>${psetName}</strong>`;
                        if (typeof pset === 'object') {
                            for (const [key, val] of Object.entries(pset)) {
                                html += `<div class="prop-row"><span class="prop-key">${key}</span>` +
                                        `<span class="prop-val">${val}</span></div>`;
                            }
                        } else {
                            html += `<div class="prop-row">${pset}</div>`;
                        }
                        html += `</div>`;
                    }
                    propContent.innerHTML = html;
                }
            } else {
                overlay.style.display = 'none';
            }
        });

        // Configure the initial camera position.
        world.camera.controls.setLookAt(20, 20, 20, 0, 0, 0);
        document.getElementById('loading').style.display = 'none';
    </script>
</body>
</html>
